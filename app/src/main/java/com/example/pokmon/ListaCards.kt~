package com.example.pokmon

import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.pokmon.API.PokemonService
import com.example.pokmon.adapter.PokemonAdapter
import com.example.pokmon.model.* // Certifique-se de que todas as classes Model est√£o importadas
import com.google.android.material.button.MaterialButton
import com.google.android.material.textfield.TextInputLayout
import com.google.gson.Gson
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

class ListaCards : AppCompatActivity() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var busca: TextInputLayout
    private lateinit var service: PokemonService
    private lateinit var btnBuscar: MaterialButton
    private lateinit var pokebola: ImageView

    private val listaAtual = mutableListOf<Item>()
    private lateinit var pokemonAdapter: PokemonAdapter
    private val TAG = "ListaCardsLog"

    // Launcher para receber o resultado do sorteio
    private val sorteioLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val data: Intent? = result.data
            val pokemonJson = data?.getStringExtra("pokemon_sorteado")

            if (pokemonJson != null) {
                val novoPokemon = Gson().fromJson(pokemonJson, Pokemon::class.java)
                adicionarPokemonSorteado(novoPokemon)
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_lista_cards)

        pokebola = findViewById(R.id.pokebola)

        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }
        recyclerView = findViewById(R.id.CardsRecycleView)
        recyclerView.layoutManager = GridLayoutManager(this, 2)

        pokemonAdapter = PokemonAdapter(listaAtual) { item: Item -> abrirDetalhe(item) }
        recyclerView.adapter = pokemonAdapter

        busca = findViewById(R.id.pesquisa)
        btnBuscar = findViewById(R.id.btnBuscar)

        val retrofit = Retrofit.Builder()
            .baseUrl("https://pokeapi.co/api/v2/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        service = retrofit.create(PokemonService::class.java)

        chamarAPI()

        btnBuscar.setOnClickListener { chamarAPI() }
        pokebola.setOnClickListener{ abrirPokebola() }
    }

    private fun chamarAPI() {
        val query = busca.editText?.text.toString().trim().lowercase()
        listaAtual.clear()
        pokemonAdapter.notifyDataSetChanged()

        if (query.isEmpty()) {
            // L√≥gica para carregar a lista inicial
            service.getInitialPokemonList().enqueue(object : Callback<PokemonListResponse> {
                override fun onResponse(call: Call<PokemonListResponse>, response: Response<PokemonListResponse>) {
                    val listaPokemons = response.body()?.results?.map { apiItem ->
                        val id = apiItem.url.trimEnd('/').split('/').last().toIntOrNull() ?: 0
                        Item(id, apiItem.name, apiItem.url)
                    }
                    if (!listaPokemons.isNullOrEmpty()) {
                        listaAtual.addAll(listaPokemons)
                        listaAtual.sortBy { it.id }
                        pokemonAdapter.notifyDataSetChanged()
                    }
                }
                override fun onFailure(call: Call<PokemonListResponse>?, t: Throwable) {
                    Log.e(TAG, "Erro ao buscar lista inicial", t)
                    Toast.makeText(this@ListaCards, "Erro ao carregar lista inicial.", Toast.LENGTH_SHORT).show()
                }
            })
        } else {
            // Caso 2: Busca Espec√≠fica (Busca o Pok√©mon para obter o URL da esp√©cie/evolu√ß√£o)
            service.getPokemonDetail(query).enqueue(object : Callback<Pokemon> {
                override fun onResponse(call: Call<Pokemon>, response: Response<Pokemon>) {
                    val pokemon = response.body()

                    if (pokemon != null) {
                        // Se encontrado, usa o URL da esp√©cie para iniciar a busca pela cadeia de evolu√ß√£o
                        fetchSpecies(pokemon.species.url)
                    } else {
                        Toast.makeText(this@ListaCards, "Pok√©mon '$query' n√£o encontrado.", Toast.LENGTH_SHORT).show()
                    }
                }
                override fun onFailure(call: Call<Pokemon>?, t: Throwable) {
                    Toast.makeText(this@ListaCards, "Erro na API ou Pok√©mon n√£o encontrado.", Toast.LENGTH_SHORT).show()
                    Log.e(TAG, "Erro ao buscar detalhes de $query", t)
                }
            })
        }
    }

    // Etapa 2: Buscar o URL da cadeia de evolu√ß√£o (Evolution Chain)
    private fun fetchSpecies(speciesUrl: String) {
        service.getPokemonSpecies(speciesUrl).enqueue(object : Callback<PokemonSpeciesResponse> {
            override fun onResponse(call: Call<PokemonSpeciesResponse>, response: Response<PokemonSpeciesResponse>) {
                val evolutionUrl = response.body()?.evolution_chain?.url

                evolutionUrl?.let {
                    val id = it.trimEnd('/').split('/').last().toIntOrNull()
                    if (id != null) {
                        fetchEvolutionChain(id)
                    } else {
                        Toast.makeText(this@ListaCards, "Cadeia de evolu√ß√£o n√£o encontrada.", Toast.LENGTH_SHORT).show()
                    }
                }
            }
            override fun onFailure(call: Call<PokemonSpeciesResponse>?, t: Throwable) {
                Log.e(TAG, "Erro ao buscar esp√©cie", t)
                Toast.makeText(this@ListaCards, "Erro ao buscar dados da esp√©cie.", Toast.LENGTH_SHORT).show()
            }
        })
    }

    // Etapa 3: Buscar a cadeia de evolu√ß√£o e popular a lista
    private fun fetchEvolutionChain(id: Int) {
        service.getEvolutionChain(id).enqueue(object : Callback<EvolutionChainResponse> {
            override fun onResponse(call: Call<EvolutionChainResponse>, response: Response<EvolutionChainResponse>) {
                response.body()?.chain?.let { chain ->
                    val evolutions = extractEvolutions(chain)

                    // Cria os Itens inicialmente com ID 0. O adapter carrega a imagem pelo NOME.
                    val items = evolutions.map { name ->
                        val url = "https://pokeapi.co/api/v2/pokemon/$name"
                        Item(0, name, url)
                    }

                    listaAtual.clear()
                    listaAtual.addAll(items)
                    pokemonAdapter.notifyDataSetChanged()

                    // üö® NOVIDADE: Busca o ID correto assincronamente e atualiza o card
                    items.forEachIndexed { index, item ->
                        fetchPokemonIdByName(item.name) { realId ->
                            if (realId > 0) {
                                // Atualiza o ID do item na lista (uso do 'copy' garante imutabilidade)
                                listaAtual[index] = item.copy(id = realId)
                                // Notifica o Adapter para redesenhar APENAS este item
                                pokemonAdapter.notifyItemChanged(index)
                            }
                        }
                    }

                } ?: Toast.makeText(this@ListaCards, "Cadeia de evolu√ß√£o vazia.", Toast.LENGTH_SHORT).show()
            }
            override fun onFailure(call: Call<EvolutionChainResponse>?, t: Throwable) {
                Log.e(TAG, "Erro ao buscar cadeia de evolu√ß√£o", t)
                Toast.makeText(this@ListaCards, "Erro ao buscar cadeia de evolu√ß√£o.", Toast.LENGTH_SHORT).show()
            }
        })
    }

    // M√©todo auxiliar para buscar o ID correto de um Pok√©mon a partir do nome
    private fun fetchPokemonIdByName(name: String, callback: (Int) -> Unit) {
        service.getPokemonDetail(name).enqueue(object : Callback<Pokemon> {
            override fun onResponse(call: Call<Pokemon>, response: Response<Pokemon>) {
                val id = response.body()?.id ?: 0
                callback(id)
            }
            override fun onFailure(call: Call<Pokemon>?, t: Throwable) {
                // Se falhar, retorna ID 0, e o Adapter continuar√° usando o nome para a imagem
                callback(0)
            }
        })
    }

    // Fun√ß√£o recursiva para extrair todos os nomes da cadeia
    private fun extractEvolutions(chain: ChainLink): List<String> {
        val evolutions = mutableListOf<String>()
        evolutions.add(chain.species.name)
        chain.evolves_to.forEach { evolutions.addAll(extractEvolutions(it)) }
        return evolutions
    }

    private fun abrirDetalhe(item: Item) {
        val intent = Intent(this, Detalhe::class.java)
        intent.putExtra("pokemonName", item.name)
        startActivity(intent)
    }

    private fun abrirPokebola(){
        val intent = Intent(this, SorteioPokemon::class.java)
        sorteioLauncher.launch(intent)
    }

    private fun adicionarPokemonSorteado(pokemon: Pokemon) {
        val id = pokemon.id
        val novoItem = Item(id, pokemon.name, "https://pokeapi.co/api/v2/pokemon/$id")

        if (listaAtual.none { it.id == id && it.id != 0 }) {

            listaAtual.add(novoItem)

            if (busca.editText?.text.toString().isEmpty()) {
                listaAtual.sortBy { it.id }
            }

            val newPosition = listaAtual.indexOfFirst { it.id == id }

            if (newPosition != -1) {
                pokemonAdapter.notifyItemInserted(newPosition)
                pokemonAdapter.notifyItemRangeChanged(0, listaAtual.size)
                recyclerView.smoothScrollToPosition(newPosition)
            } else {
                pokemonAdapter.notifyDataSetChanged()
            }

            Toast.makeText(this, "üéâ ${pokemon.name.replaceFirstChar { it.uppercase() }} sorteado e adicionado!", Toast.LENGTH_LONG).show()
        } else {
            Toast.makeText(this, "${pokemon.name.replaceFirstChar { it.uppercase() }} j√° estava na lista!", Toast.LENGTH_SHORT).show()
        }
    }
}